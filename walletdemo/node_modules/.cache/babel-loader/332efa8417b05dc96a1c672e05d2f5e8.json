{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar secp256k1 = __importStar(require(\"secp256k1\"));\nfunction privateKeyVerify(privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n}\nexports.privateKeyVerify = privateKeyVerify;\nfunction publicKeyCreate(privateKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  return Buffer.from(secp256k1.publicKeyCreate(privateKey, compressed));\n}\nexports.publicKeyCreate = publicKeyCreate;\nfunction publicKeyVerify(publicKey) {\n  return secp256k1.publicKeyVerify(publicKey);\n}\nexports.publicKeyVerify = publicKeyVerify;\nfunction publicKeyConvert(publicKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  return Buffer.from(secp256k1.publicKeyConvert(publicKey, compressed));\n}\nexports.publicKeyConvert = publicKeyConvert;\nfunction privateKeyTweakAdd(publicKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(publicKey), tweak));\n}\nexports.privateKeyTweakAdd = privateKeyTweakAdd;\nfunction publicKeyTweakAdd(publicKey, tweak, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(publicKey), tweak, compressed));\n}\nexports.publicKeyTweakAdd = publicKeyTweakAdd;\nfunction sign(message, privateKey) {\n  var ret = secp256k1.ecdsaSign(message, privateKey);\n  return {\n    signature: Buffer.from(ret.signature),\n    recovery: ret.recid\n  };\n}\nexports.sign = sign;\nfunction verify(message, signature, publicKey) {\n  return secp256k1.ecdsaVerify(signature, message, publicKey);\n}\nexports.verify = verify;","map":{"version":3,"mappings":";;;;;;;;;;;;AAAA;AAEA,SAAgBA,gBAAgB,CAACC,UAAkB;EACjD,OAAOC,SAAS,CAACF,gBAAgB,CAACC,UAAU,CAAC;AAC/C;AAFAE;AAIA,SAAgBC,eAAe,CAACH,UAAkB,EAAEI,UAAiB;EAAjB;IAAAA,iBAAiB;EAAA;EACnE,OAAOC,MAAM,CAACC,IAAI,CAACL,SAAS,CAACE,eAAe,CAACH,UAAU,EAAEI,UAAU,CAAC,CAAC;AACvE;AAFAF;AAIA,SAAgBK,eAAe,CAACC,SAAiB;EAC/C,OAAOP,SAAS,CAACM,eAAe,CAACC,SAAS,CAAC;AAC7C;AAFAN;AAIA,SAAgBO,gBAAgB,CAACD,SAAiB,EAAEJ,UAAiB;EAAjB;IAAAA,iBAAiB;EAAA;EACnE,OAAOC,MAAM,CAACC,IAAI,CAACL,SAAS,CAACQ,gBAAgB,CAACD,SAAS,EAAEJ,UAAU,CAAC,CAAC;AACvE;AAFAF;AAIA,SAAgBQ,kBAAkB,CAACF,SAAiB,EAAEG,KAAa;EACjE,OAAON,MAAM,CAACC,IAAI,CAChBL,SAAS,CAACS,kBAAkB,CAACL,MAAM,CAACC,IAAI,CAACE,SAAS,CAAC,EAAEG,KAAK,CAAC,CAC5D;AACH;AAJAT;AAMA,SAAgBU,iBAAiB,CAC/BJ,SAAiB,EACjBG,KAAa,EACbP,UAAiB;EAAjB;IAAAA,iBAAiB;EAAA;EAEjB,OAAOC,MAAM,CAACC,IAAI,CAChBL,SAAS,CAACW,iBAAiB,CAACP,MAAM,CAACC,IAAI,CAACE,SAAS,CAAC,EAAEG,KAAK,EAAEP,UAAU,CAAC,CACvE;AACH;AARAF;AAUA,SAAgBW,IAAI,CAClBC,OAAe,EACfd,UAAkB;EAElB,IAAMe,GAAG,GAAGd,SAAS,CAACe,SAAS,CAACF,OAAO,EAAEd,UAAU,CAAC;EACpD,OAAO;IAAEiB,SAAS,EAAEZ,MAAM,CAACC,IAAI,CAACS,GAAG,CAACE,SAAS,CAAC;IAAEC,QAAQ,EAAEH,GAAG,CAACI;EAAK,CAAE;AACvE;AANAjB;AAQA,SAAgBkB,MAAM,CACpBN,OAAe,EACfG,SAAiB,EACjBT,SAAiB;EAEjB,OAAOP,SAAS,CAACoB,WAAW,CAACJ,SAAS,EAAEH,OAAO,EAAEN,SAAS,CAAC;AAC7D;AANAN","names":["privateKeyVerify","privateKey","secp256k1","exports","publicKeyCreate","compressed","Buffer","from","publicKeyVerify","publicKey","publicKeyConvert","privateKeyTweakAdd","tweak","publicKeyTweakAdd","sign","message","ret","ecdsaSign","signature","recovery","recid","verify","ecdsaVerify"],"sources":["/Users/zhangyuanyi/Downloads/Wallet/walletdemo/node_modules/ethereum-cryptography/src/shims/hdkey-secp256k1v3.ts"],"sourcesContent":["import * as secp256k1 from \"secp256k1\";\n\nexport function privateKeyVerify(privateKey: Buffer): boolean {\n  return secp256k1.privateKeyVerify(privateKey);\n}\n\nexport function publicKeyCreate(privateKey: Buffer, compressed = true): Buffer {\n  return Buffer.from(secp256k1.publicKeyCreate(privateKey, compressed));\n}\n\nexport function publicKeyVerify(publicKey: Buffer): boolean {\n  return secp256k1.publicKeyVerify(publicKey);\n}\n\nexport function publicKeyConvert(publicKey: Buffer, compressed = true): Buffer {\n  return Buffer.from(secp256k1.publicKeyConvert(publicKey, compressed));\n}\n\nexport function privateKeyTweakAdd(publicKey: Buffer, tweak: Buffer): Buffer {\n  return Buffer.from(\n    secp256k1.privateKeyTweakAdd(Buffer.from(publicKey), tweak)\n  );\n}\n\nexport function publicKeyTweakAdd(\n  publicKey: Buffer,\n  tweak: Buffer,\n  compressed = true\n): Buffer {\n  return Buffer.from(\n    secp256k1.publicKeyTweakAdd(Buffer.from(publicKey), tweak, compressed)\n  );\n}\n\nexport function sign(\n  message: Buffer,\n  privateKey: Buffer\n): { signature: Buffer; recovery: number } {\n  const ret = secp256k1.ecdsaSign(message, privateKey);\n  return { signature: Buffer.from(ret.signature), recovery: ret.recid };\n}\n\nexport function verify(\n  message: Buffer,\n  signature: Buffer,\n  publicKey: Buffer\n): boolean {\n  return secp256k1.ecdsaVerify(signature, message, publicKey);\n}\n"]},"metadata":{},"sourceType":"script"}