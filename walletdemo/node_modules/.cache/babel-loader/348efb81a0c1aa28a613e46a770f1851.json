{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseTransaction = void 0;\nvar common_1 = __importStar(require(\"@ethereumjs/common\"));\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar types_1 = require(\"./types\");\n/**\n * This base class will likely be subject to further\n * refactoring along the introduction of additional tx types\n * on the Ethereum network.\n *\n * It is therefore not recommended to use directly.\n */\nvar BaseTransaction = /** @class */function () {\n  function BaseTransaction(txData) {\n    this.cache = {\n      hash: undefined,\n      dataFee: undefined\n    };\n    /**\n     * List of tx type defining EIPs,\n     * e.g. 1559 (fee market) and 2930 (access lists)\n     * for FeeMarketEIP1559Transaction objects\n     */\n    this.activeCapabilities = [];\n    /**\n     * The default chain the tx falls back to if no Common\n     * is provided and if the chain can't be derived from\n     * a passed in chainId (only EIP-2718 typed txs) or\n     * EIP-155 signature (legacy txs).\n     *\n     * @hidden\n     */\n    this.DEFAULT_CHAIN = common_1.Chain.Mainnet;\n    /**\n     * The default HF if the tx type is active on that HF\n     * or the first greater HF where the tx is active.\n     *\n     * @hidden\n     */\n    this.DEFAULT_HARDFORK = common_1.Hardfork.Istanbul;\n    var nonce = txData.nonce,\n      gasLimit = txData.gasLimit,\n      to = txData.to,\n      value = txData.value,\n      data = txData.data,\n      v = txData.v,\n      r = txData.r,\n      s = txData.s,\n      type = txData.type;\n    this._type = new ethereumjs_util_1.BN((0, ethereumjs_util_1.toBuffer)(type)).toNumber();\n    var toB = (0, ethereumjs_util_1.toBuffer)(to === '' ? '0x' : to);\n    var vB = (0, ethereumjs_util_1.toBuffer)(v === '' ? '0x' : v);\n    var rB = (0, ethereumjs_util_1.toBuffer)(r === '' ? '0x' : r);\n    var sB = (0, ethereumjs_util_1.toBuffer)(s === '' ? '0x' : s);\n    this.nonce = new ethereumjs_util_1.BN((0, ethereumjs_util_1.toBuffer)(nonce === '' ? '0x' : nonce));\n    this.gasLimit = new ethereumjs_util_1.BN((0, ethereumjs_util_1.toBuffer)(gasLimit === '' ? '0x' : gasLimit));\n    this.to = toB.length > 0 ? new ethereumjs_util_1.Address(toB) : undefined;\n    this.value = new ethereumjs_util_1.BN((0, ethereumjs_util_1.toBuffer)(value === '' ? '0x' : value));\n    this.data = (0, ethereumjs_util_1.toBuffer)(data === '' ? '0x' : data);\n    this.v = vB.length > 0 ? new ethereumjs_util_1.BN(vB) : undefined;\n    this.r = rB.length > 0 ? new ethereumjs_util_1.BN(rB) : undefined;\n    this.s = sB.length > 0 ? new ethereumjs_util_1.BN(sB) : undefined;\n    this._validateCannotExceedMaxInteger({\n      value: this.value,\n      r: this.r,\n      s: this.s\n    });\n    // geth limits gasLimit to 2^64-1\n    this._validateCannotExceedMaxInteger({\n      gasLimit: this.gasLimit\n    }, 64);\n    // EIP-2681 limits nonce to 2^64-1 (cannot equal 2^64-1)\n    this._validateCannotExceedMaxInteger({\n      nonce: this.nonce\n    }, 64, true);\n  }\n  Object.defineProperty(BaseTransaction.prototype, \"transactionType\", {\n    /**\n     * Alias for {@link BaseTransaction.type}\n     *\n     * @deprecated Use `type` instead\n     */\n    get: function () {\n      return this.type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTransaction.prototype, \"type\", {\n    /**\n     * Returns the transaction type.\n     *\n     * Note: legacy txs will return tx type `0`.\n     */\n    get: function () {\n      return this._type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Checks if a tx type defining capability is active\n   * on a tx, for example the EIP-1559 fee market mechanism\n   * or the EIP-2930 access list feature.\n   *\n   * Note that this is different from the tx type itself,\n   * so EIP-2930 access lists can very well be active\n   * on an EIP-1559 tx for example.\n   *\n   * This method can be useful for feature checks if the\n   * tx type is unknown (e.g. when instantiated with\n   * the tx factory).\n   *\n   * See `Capabilites` in the `types` module for a reference\n   * on all supported capabilities.\n   */\n  BaseTransaction.prototype.supports = function (capability) {\n    return this.activeCapabilities.includes(capability);\n  };\n  BaseTransaction.prototype.validate = function (stringError) {\n    if (stringError === void 0) {\n      stringError = false;\n    }\n    var errors = [];\n    if (this.getBaseFee().gt(this.gasLimit)) {\n      errors.push(\"gasLimit is too low. given \".concat(this.gasLimit, \", need at least \").concat(this.getBaseFee()));\n    }\n    if (this.isSigned() && !this.verifySignature()) {\n      errors.push('Invalid Signature');\n    }\n    return stringError ? errors : errors.length === 0;\n  };\n  /**\n   * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)\n   */\n  BaseTransaction.prototype.getBaseFee = function () {\n    var fee = this.getDataFee().addn(this.common.param('gasPrices', 'tx'));\n    if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {\n      fee.iaddn(this.common.param('gasPrices', 'txCreation'));\n    }\n    return fee;\n  };\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  BaseTransaction.prototype.getDataFee = function () {\n    var txDataZero = this.common.param('gasPrices', 'txDataZero');\n    var txDataNonZero = this.common.param('gasPrices', 'txDataNonZero');\n    var cost = 0;\n    for (var i = 0; i < this.data.length; i++) {\n      this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;\n    }\n    cost = new ethereumjs_util_1.BN(cost);\n    if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {\n      var dataLength = Math.ceil(this.data.length / 32);\n      var initCodeCost = new ethereumjs_util_1.BN(this.common.param('gasPrices', 'initCodeWordCost')).imuln(dataLength);\n      cost.iadd(initCodeCost);\n    }\n    return cost;\n  };\n  /**\n   * If the tx's `to` is to the creation address\n   */\n  BaseTransaction.prototype.toCreationAddress = function () {\n    return this.to === undefined || this.to.buf.length === 0;\n  };\n  BaseTransaction.prototype.isSigned = function () {\n    var _a = this,\n      v = _a.v,\n      r = _a.r,\n      s = _a.s;\n    if (this.type === 0) {\n      if (!v || !r || !s) {\n        return false;\n      } else {\n        return true;\n      }\n    } else {\n      if (v === undefined || !r || !s) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  };\n  /**\n   * Determines if the signature is valid\n   */\n  BaseTransaction.prototype.verifySignature = function () {\n    try {\n      // Main signature verification is done in `getSenderPublicKey()`\n      var publicKey = this.getSenderPublicKey();\n      return (0, ethereumjs_util_1.unpadBuffer)(publicKey).length !== 0;\n    } catch (e) {\n      return false;\n    }\n  };\n  /**\n   * Returns the sender's address\n   */\n  BaseTransaction.prototype.getSenderAddress = function () {\n    return new ethereumjs_util_1.Address((0, ethereumjs_util_1.publicToAddress)(this.getSenderPublicKey()));\n  };\n  /**\n   * Signs a transaction.\n   *\n   * Note that the signed tx is returned as a new object,\n   * use as follows:\n   * ```javascript\n   * const signedTx = tx.sign(privateKey)\n   * ```\n   */\n  BaseTransaction.prototype.sign = function (privateKey) {\n    if (privateKey.length !== 32) {\n      var msg = this._errorMsg('Private key must be 32 bytes in length.');\n      throw new Error(msg);\n    }\n    // Hack for the constellation that we have got a legacy tx after spuriousDragon with a non-EIP155 conforming signature\n    // and want to recreate a signature (where EIP155 should be applied)\n    // Leaving this hack lets the legacy.spec.ts -> sign(), verifySignature() test fail\n    // 2021-06-23\n    var hackApplied = false;\n    if (this.type === 0 && this.common.gteHardfork('spuriousDragon') && !this.supports(types_1.Capability.EIP155ReplayProtection)) {\n      this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);\n      hackApplied = true;\n    }\n    var msgHash = this.getMessageToSign(true);\n    var _a = (0, ethereumjs_util_1.ecsign)(msgHash, privateKey),\n      v = _a.v,\n      r = _a.r,\n      s = _a.s;\n    var tx = this._processSignature(v, r, s);\n    // Hack part 2\n    if (hackApplied) {\n      var index = this.activeCapabilities.indexOf(types_1.Capability.EIP155ReplayProtection);\n      if (index > -1) {\n        this.activeCapabilities.splice(index, 1);\n      }\n    }\n    return tx;\n  };\n  /**\n   * Does chain ID checks on common and returns a common\n   * to be used on instantiation\n   * @hidden\n   *\n   * @param common - {@link Common} instance from tx options\n   * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)\n   */\n  BaseTransaction.prototype._getCommon = function (common, chainId) {\n    var _a;\n    // Chain ID provided\n    if (chainId) {\n      var chainIdBN = new ethereumjs_util_1.BN((0, ethereumjs_util_1.toBuffer)(chainId));\n      if (common) {\n        if (!common.chainIdBN().eq(chainIdBN)) {\n          var msg = this._errorMsg('The chain ID does not match the chain ID of Common');\n          throw new Error(msg);\n        }\n        // Common provided, chain ID does match\n        // -> Return provided Common\n        return common.copy();\n      } else {\n        if (common_1.default.isSupportedChainId(chainIdBN)) {\n          // No Common, chain ID supported by Common\n          // -> Instantiate Common with chain ID\n          return new common_1.default({\n            chain: chainIdBN,\n            hardfork: this.DEFAULT_HARDFORK\n          });\n        } else {\n          // No Common, chain ID not supported by Common\n          // -> Instantiate custom Common derived from DEFAULT_CHAIN\n          return common_1.default.forCustomChain(this.DEFAULT_CHAIN, {\n            name: 'custom-chain',\n            networkId: chainIdBN,\n            chainId: chainIdBN\n          }, this.DEFAULT_HARDFORK);\n        }\n      }\n    } else {\n      // No chain ID provided\n      // -> return Common provided or create new default Common\n      return (_a = common === null || common === void 0 ? void 0 : common.copy()) !== null && _a !== void 0 ? _a : new common_1.default({\n        chain: this.DEFAULT_CHAIN,\n        hardfork: this.DEFAULT_HARDFORK\n      });\n    }\n  };\n  /**\n   * Validates that an object with BN values cannot exceed the specified bit limit.\n   * @param values Object containing string keys and BN values\n   * @param bits Number of bits to check (64 or 256)\n   * @param cannotEqual Pass true if the number also cannot equal one less the maximum value\n   */\n  BaseTransaction.prototype._validateCannotExceedMaxInteger = function (values, bits, cannotEqual) {\n    var e_1, _a;\n    if (bits === void 0) {\n      bits = 256;\n    }\n    if (cannotEqual === void 0) {\n      cannotEqual = false;\n    }\n    try {\n      for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          key = _d[0],\n          value = _d[1];\n        switch (bits) {\n          case 64:\n            if (cannotEqual) {\n              if (value === null || value === void 0 ? void 0 : value.gte(ethereumjs_util_1.MAX_UINT64)) {\n                var msg = this._errorMsg(\"\".concat(key, \" cannot equal or exceed MAX_UINT64 (2^64-1), given \").concat(value));\n                throw new Error(msg);\n              }\n            } else {\n              if (value === null || value === void 0 ? void 0 : value.gt(ethereumjs_util_1.MAX_UINT64)) {\n                var msg = this._errorMsg(\"\".concat(key, \" cannot exceed MAX_UINT64 (2^64-1), given \").concat(value));\n                throw new Error(msg);\n              }\n            }\n            break;\n          case 256:\n            if (cannotEqual) {\n              if (value === null || value === void 0 ? void 0 : value.gte(ethereumjs_util_1.MAX_INTEGER)) {\n                var msg = this._errorMsg(\"\".concat(key, \" cannot equal or exceed MAX_INTEGER (2^256-1), given \").concat(value));\n                throw new Error(msg);\n              }\n            } else {\n              if (value === null || value === void 0 ? void 0 : value.gt(ethereumjs_util_1.MAX_INTEGER)) {\n                var msg = this._errorMsg(\"\".concat(key, \" cannot exceed MAX_INTEGER (2^256-1), given \").concat(value));\n                throw new Error(msg);\n              }\n            }\n            break;\n          default:\n            {\n              var msg = this._errorMsg('unimplemented bits value');\n              throw new Error(msg);\n            }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  /**\n   * Returns the shared error postfix part for _error() method\n   * tx type implementations.\n   */\n  BaseTransaction.prototype._getSharedErrorPostfix = function () {\n    var hash = '';\n    try {\n      hash = this.isSigned() ? (0, ethereumjs_util_1.bufferToHex)(this.hash()) : 'not available (unsigned)';\n    } catch (e) {\n      hash = 'error';\n    }\n    var isSigned = '';\n    try {\n      isSigned = this.isSigned().toString();\n    } catch (e) {\n      hash = 'error';\n    }\n    var hf = '';\n    try {\n      hf = this.common.hardfork();\n    } catch (e) {\n      hf = 'error';\n    }\n    var postfix = \"tx type=\".concat(this.type, \" hash=\").concat(hash, \" nonce=\").concat(this.nonce, \" value=\").concat(this.value, \" \");\n    postfix += \"signed=\".concat(isSigned, \" hf=\").concat(hf);\n    return postfix;\n  };\n  return BaseTransaction;\n}();\nexports.BaseTransaction = BaseTransaction;","map":{"version":3,"mappings":"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","names":["txData","hash","undefined","dataFee","common_1","Mainnet","Istanbul","gasLimit","to","value","data","v","r","s","type","_type","ethereumjs_util_1","toNumber","toB","vB","rB","sB","nonce","length","_validateCannotExceedMaxInteger","Object","BaseTransaction","capability","activeCapabilities","includes","stringError","errors","getBaseFee","gt","push","isSigned","verifySignature","fee","getDataFee","addn","common","param","gteHardfork","toCreationAddress","iaddn","txDataZero","txDataNonZero","cost","i","isActivatedEIP","dataLength","Math","ceil","initCodeCost","imuln","iadd","buf","publicKey","getSenderPublicKey","e","privateKey","msg","_errorMsg","Error","hackApplied","supports","types_1","EIP155ReplayProtection","msgHash","getMessageToSign","tx","_processSignature","index","indexOf","splice","chainId","chainIdBN","eq","copy","isSupportedChainId","chain","hardfork","DEFAULT_HARDFORK","forCustomChain","DEFAULT_CHAIN","name","networkId","values","bits","cannotEqual","entries","key","gte","toString","hf","postfix","exports"],"sources":["/Users/zhangyuanyi/Downloads/Wallet/walletdemo/node_modules/eth-crypto/node_modules/@ethereumjs/tx/src/baseTransaction.ts"],"sourcesContent":["import Common, { Chain, Hardfork } from '@ethereumjs/common'\nimport {\n  Address,\n  BN,\n  toBuffer,\n  MAX_INTEGER,\n  MAX_UINT64,\n  unpadBuffer,\n  ecsign,\n  publicToAddress,\n  BNLike,\n  bufferToHex,\n} from 'ethereumjs-util'\nimport {\n  TxData,\n  JsonTx,\n  AccessListEIP2930ValuesArray,\n  AccessListEIP2930TxData,\n  FeeMarketEIP1559ValuesArray,\n  FeeMarketEIP1559TxData,\n  TxValuesArray,\n  Capability,\n} from './types'\n\ninterface TransactionCache {\n  hash: Buffer | undefined\n  dataFee?: {\n    value: BN\n    hardfork: string | Hardfork\n  }\n}\n\n/**\n * This base class will likely be subject to further\n * refactoring along the introduction of additional tx types\n * on the Ethereum network.\n *\n * It is therefore not recommended to use directly.\n */\nexport abstract class BaseTransaction<TransactionObject> {\n  private readonly _type: number\n\n  public readonly nonce: BN\n  public readonly gasLimit: BN\n  public readonly to?: Address\n  public readonly value: BN\n  public readonly data: Buffer\n\n  public readonly v?: BN\n  public readonly r?: BN\n  public readonly s?: BN\n\n  public readonly common!: Common\n\n  protected cache: TransactionCache = {\n    hash: undefined,\n    dataFee: undefined,\n  }\n\n  /**\n   * List of tx type defining EIPs,\n   * e.g. 1559 (fee market) and 2930 (access lists)\n   * for FeeMarketEIP1559Transaction objects\n   */\n  protected activeCapabilities: number[] = []\n\n  /**\n   * The default chain the tx falls back to if no Common\n   * is provided and if the chain can't be derived from\n   * a passed in chainId (only EIP-2718 typed txs) or\n   * EIP-155 signature (legacy txs).\n   *\n   * @hidden\n   */\n  protected DEFAULT_CHAIN = Chain.Mainnet\n\n  /**\n   * The default HF if the tx type is active on that HF\n   * or the first greater HF where the tx is active.\n   *\n   * @hidden\n   */\n  protected DEFAULT_HARDFORK: string | Hardfork = Hardfork.Istanbul\n\n  constructor(txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData) {\n    const { nonce, gasLimit, to, value, data, v, r, s, type } = txData\n    this._type = new BN(toBuffer(type)).toNumber()\n\n    const toB = toBuffer(to === '' ? '0x' : to)\n    const vB = toBuffer(v === '' ? '0x' : v)\n    const rB = toBuffer(r === '' ? '0x' : r)\n    const sB = toBuffer(s === '' ? '0x' : s)\n\n    this.nonce = new BN(toBuffer(nonce === '' ? '0x' : nonce))\n    this.gasLimit = new BN(toBuffer(gasLimit === '' ? '0x' : gasLimit))\n    this.to = toB.length > 0 ? new Address(toB) : undefined\n    this.value = new BN(toBuffer(value === '' ? '0x' : value))\n    this.data = toBuffer(data === '' ? '0x' : data)\n\n    this.v = vB.length > 0 ? new BN(vB) : undefined\n    this.r = rB.length > 0 ? new BN(rB) : undefined\n    this.s = sB.length > 0 ? new BN(sB) : undefined\n\n    this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s })\n\n    // geth limits gasLimit to 2^64-1\n    this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64)\n\n    // EIP-2681 limits nonce to 2^64-1 (cannot equal 2^64-1)\n    this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true)\n  }\n\n  /**\n   * Alias for {@link BaseTransaction.type}\n   *\n   * @deprecated Use `type` instead\n   */\n  get transactionType(): number {\n    return this.type\n  }\n\n  /**\n   * Returns the transaction type.\n   *\n   * Note: legacy txs will return tx type `0`.\n   */\n  get type() {\n    return this._type\n  }\n\n  /**\n   * Checks if a tx type defining capability is active\n   * on a tx, for example the EIP-1559 fee market mechanism\n   * or the EIP-2930 access list feature.\n   *\n   * Note that this is different from the tx type itself,\n   * so EIP-2930 access lists can very well be active\n   * on an EIP-1559 tx for example.\n   *\n   * This method can be useful for feature checks if the\n   * tx type is unknown (e.g. when instantiated with\n   * the tx factory).\n   *\n   * See `Capabilites` in the `types` module for a reference\n   * on all supported capabilities.\n   */\n  supports(capability: Capability) {\n    return this.activeCapabilities.includes(capability)\n  }\n\n  /**\n   * Checks if the transaction has the minimum amount of gas required\n   * (DataFee + TxFee + Creation Fee).\n   */\n  validate(): boolean\n  validate(stringError: false): boolean\n  validate(stringError: true): string[]\n  validate(stringError: boolean = false): boolean | string[] {\n    const errors = []\n\n    if (this.getBaseFee().gt(this.gasLimit)) {\n      errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`)\n    }\n\n    if (this.isSigned() && !this.verifySignature()) {\n      errors.push('Invalid Signature')\n    }\n\n    return stringError ? errors : errors.length === 0\n  }\n\n  /**\n   * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)\n   */\n  getBaseFee(): BN {\n    const fee = this.getDataFee().addn(this.common.param('gasPrices', 'tx'))\n    if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {\n      fee.iaddn(this.common.param('gasPrices', 'txCreation'))\n    }\n    return fee\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): BN {\n    const txDataZero = this.common.param('gasPrices', 'txDataZero')\n    const txDataNonZero = this.common.param('gasPrices', 'txDataNonZero')\n\n    let cost: number | BN = 0\n    for (let i = 0; i < this.data.length; i++) {\n      this.data[i] === 0 ? (cost += txDataZero) : (cost += txDataNonZero)\n    }\n\n    cost = new BN(cost)\n    if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {\n      const dataLength = Math.ceil(this.data.length / 32)\n      const initCodeCost = new BN(this.common.param('gasPrices', 'initCodeWordCost')).imuln(\n        dataLength\n      )\n      cost.iadd(initCodeCost)\n    }\n\n    return cost\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  abstract getUpfrontCost(): BN\n\n  /**\n   * If the tx's `to` is to the creation address\n   */\n  toCreationAddress(): boolean {\n    return this.to === undefined || this.to.buf.length === 0\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of this transaction, in order.\n   *\n   * Use {@link BaseTransaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link BaseTransaction.getMessageToSign}.\n   */\n  abstract raw(): TxValuesArray | AccessListEIP2930ValuesArray | FeeMarketEIP1559ValuesArray\n\n  /**\n   * Returns the encoding of the transaction.\n   */\n  abstract serialize(): Buffer\n\n  // Returns the unsigned tx (hashed or raw), which is used to sign the transaction.\n  //\n  // Note: do not use code docs here since VS Studio is then not able to detect the\n  // comments from the inherited methods\n  abstract getMessageToSign(hashMessage: false): Buffer | Buffer[]\n  abstract getMessageToSign(hashMessage?: true): Buffer\n\n  abstract hash(): Buffer\n\n  abstract getMessageToVerifySignature(): Buffer\n\n  public isSigned(): boolean {\n    const { v, r, s } = this\n    if (this.type === 0) {\n      if (!v || !r || !s) {\n        return false\n      } else {\n        return true\n      }\n    } else {\n      if (v === undefined || !r || !s) {\n        return false\n      } else {\n        return true\n      }\n    }\n  }\n\n  /**\n   * Determines if the signature is valid\n   */\n  verifySignature(): boolean {\n    try {\n      // Main signature verification is done in `getSenderPublicKey()`\n      const publicKey = this.getSenderPublicKey()\n      return unpadBuffer(publicKey).length !== 0\n    } catch (e: any) {\n      return false\n    }\n  }\n\n  /**\n   * Returns the sender's address\n   */\n  getSenderAddress(): Address {\n    return new Address(publicToAddress(this.getSenderPublicKey()))\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  abstract getSenderPublicKey(): Buffer\n\n  /**\n   * Signs a transaction.\n   *\n   * Note that the signed tx is returned as a new object,\n   * use as follows:\n   * ```javascript\n   * const signedTx = tx.sign(privateKey)\n   * ```\n   */\n  sign(privateKey: Buffer): TransactionObject {\n    if (privateKey.length !== 32) {\n      const msg = this._errorMsg('Private key must be 32 bytes in length.')\n      throw new Error(msg)\n    }\n\n    // Hack for the constellation that we have got a legacy tx after spuriousDragon with a non-EIP155 conforming signature\n    // and want to recreate a signature (where EIP155 should be applied)\n    // Leaving this hack lets the legacy.spec.ts -> sign(), verifySignature() test fail\n    // 2021-06-23\n    let hackApplied = false\n    if (\n      this.type === 0 &&\n      this.common.gteHardfork('spuriousDragon') &&\n      !this.supports(Capability.EIP155ReplayProtection)\n    ) {\n      this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n      hackApplied = true\n    }\n\n    const msgHash = this.getMessageToSign(true)\n    const { v, r, s } = ecsign(msgHash, privateKey)\n    const tx = this._processSignature(v, r, s)\n\n    // Hack part 2\n    if (hackApplied) {\n      const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection)\n      if (index > -1) {\n        this.activeCapabilities.splice(index, 1)\n      }\n    }\n\n    return tx\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  abstract toJSON(): JsonTx\n\n  // Accept the v,r,s values from the `sign` method, and convert this into a TransactionObject\n  protected abstract _processSignature(v: number, r: Buffer, s: Buffer): TransactionObject\n\n  /**\n   * Does chain ID checks on common and returns a common\n   * to be used on instantiation\n   * @hidden\n   *\n   * @param common - {@link Common} instance from tx options\n   * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)\n   */\n  protected _getCommon(common?: Common, chainId?: BNLike) {\n    // Chain ID provided\n    if (chainId) {\n      const chainIdBN = new BN(toBuffer(chainId))\n      if (common) {\n        if (!common.chainIdBN().eq(chainIdBN)) {\n          const msg = this._errorMsg('The chain ID does not match the chain ID of Common')\n          throw new Error(msg)\n        }\n        // Common provided, chain ID does match\n        // -> Return provided Common\n        return common.copy()\n      } else {\n        if (Common.isSupportedChainId(chainIdBN)) {\n          // No Common, chain ID supported by Common\n          // -> Instantiate Common with chain ID\n          return new Common({ chain: chainIdBN, hardfork: this.DEFAULT_HARDFORK })\n        } else {\n          // No Common, chain ID not supported by Common\n          // -> Instantiate custom Common derived from DEFAULT_CHAIN\n          return Common.forCustomChain(\n            this.DEFAULT_CHAIN,\n            {\n              name: 'custom-chain',\n              networkId: chainIdBN,\n              chainId: chainIdBN,\n            },\n            this.DEFAULT_HARDFORK\n          )\n        }\n      }\n    } else {\n      // No chain ID provided\n      // -> return Common provided or create new default Common\n      return (\n        common?.copy() ?? new Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK })\n      )\n    }\n  }\n\n  /**\n   * Validates that an object with BN values cannot exceed the specified bit limit.\n   * @param values Object containing string keys and BN values\n   * @param bits Number of bits to check (64 or 256)\n   * @param cannotEqual Pass true if the number also cannot equal one less the maximum value\n   */\n  protected _validateCannotExceedMaxInteger(\n    values: { [key: string]: BN | undefined },\n    bits = 256,\n    cannotEqual = false\n  ) {\n    for (const [key, value] of Object.entries(values)) {\n      switch (bits) {\n        case 64:\n          if (cannotEqual) {\n            if (value?.gte(MAX_UINT64)) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value?.gt(MAX_UINT64)) {\n              const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`)\n              throw new Error(msg)\n            }\n          }\n          break\n        case 256:\n          if (cannotEqual) {\n            if (value?.gte(MAX_INTEGER)) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value?.gt(MAX_INTEGER)) {\n              const msg = this._errorMsg(\n                `${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          }\n          break\n        default: {\n          const msg = this._errorMsg('unimplemented bits value')\n          throw new Error(msg)\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public abstract errorStr(): string\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected abstract _errorMsg(msg: string): string\n\n  /**\n   * Returns the shared error postfix part for _error() method\n   * tx type implementations.\n   */\n  protected _getSharedErrorPostfix() {\n    let hash = ''\n    try {\n      hash = this.isSigned() ? bufferToHex(this.hash()) : 'not available (unsigned)'\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let isSigned = ''\n    try {\n      isSigned = this.isSigned().toString()\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let hf = ''\n    try {\n      hf = this.common.hardfork()\n    } catch (e: any) {\n      hf = 'error'\n    }\n\n    let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `\n    postfix += `signed=${isSigned} hf=${hf}`\n\n    return postfix\n  }\n}\n"]},"metadata":{},"sourceType":"script"}